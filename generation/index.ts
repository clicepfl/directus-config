import { writeFile } from "node:fs/promises";
import { exit } from "node:process";
import type { ObjectSubtype, OpenAPI3 } from "openapi-typescript";
import openapiTS, { astToString } from "openapi-typescript";

try {
  await main();
} catch (e) {
  console.error((e as Error).message);
  console.error(
    `Usage is ${process.argv[0]} ${process.argv[1]} <DIRECTUS_URL> <DIRECTUS_TOKEN> <SINGLETONS_CSV> <OUTPUT>`,
  );
  exit(1);
}

// Updates the relation fields generated by Directus to more accurately represent the field's type.
// Any field that would be represented as `(Item | number)[]` will be updated to look like
// `Item[] | number[]` instead.
/**
 * Updates the relation fields generated by Directus to more accurately represent the field's type.
 *
 * Any field that would be represented as `(Item | number)[]` will be updated to look like
 * `Item[] | number[]` instead.
 *
 * @param oas The `OpenAPI3` schema to update.
 */
function fixRelations(oas: OpenAPI3) {
  for (const schema of Object.values(oas.components?.schemas || {})) {
    if (schema.type !== "object") {
      continue;
    }

    const obj = schema as ObjectSubtype;

    if (typeof schema.properties !== "object") {
      continue;
    }

    for (const [key, fieldSchema] of Object.entries(schema.properties || {})) {
      if (
        "type" in fieldSchema &&
        fieldSchema.type == "array" &&
        typeof fieldSchema.items === "object" &&
        "oneOf" in fieldSchema.items
      ) {
        // Error is expected because `OpenAPI3` makes the `type` field mandatory, while it is
        // actually not necessary.
        // @ts-expect-error
        schema.properties[key] = {
          nullable: fieldSchema.nullable,
          oneOf: fieldSchema.items.oneOf?.map((e) => ({
            type: "array",
            items: e,
          })),
        };
      }
    }
  }
}

/**
 * Generate a `Schema` object that can be used by directus-sdk.
 *
 * @param oas The `OpenAPI3` schema of the directus instance
 * @param singletons List of the singletons collections
 * @returns a string representatin of a `Schema` object, usable with directus-sdk.
 */
function generateSchema(oas: OpenAPI3, singletons: string[]) {
  let s = "export type Schema = {\n";

  // Filters all collections that need to be exposed and sort them for convenience.
  let collections = Object.entries(oas.components?.schemas || {})
    .filter(
      (e) =>
        typeof e[1]["x-collection"] === "string" &&
        !e[1]["x-collection"].startsWith("directus_"),
    )
    .toSorted((a, b) => a[0].localeCompare(b[0]));

  for (const [key, schema] of collections) {
    const name = schema["x-collection"];
    if (!name) {
      continue;
    }

    const isSingleton = singletons.indexOf(name) !== -1;

    s += `  ${name}: components["schemas"]["${key}"]${isSingleton ? "" : "[]"},\n`;
  }

  s += "}";

  return s;
}

async function main() {
  function fail(msg: string): never {
    throw new Error(msg);
  }

  const url = process.argv[2] || fail("Missing url");
  const token = process.argv[3] || fail("Missing token");
  const singletons = (process.argv[4] || fail("Missing singletons list")).split(
    ",",
  );
  const output = process.argv[5] || fail("Missing output");

  console.log(`Fetching OAS specification from ${url}`);
  let oas: OpenAPI3 = await (
    await fetch(url, {
      headers: { Authorization: `Bearer ${token}` },
    })
  ).json();

  fixRelations(oas);

  console.log("Generating Typescript");
  let ts = astToString(await openapiTS(oas));

  ts += "\n";
  ts += generateSchema(oas, singletons);

  console.log(`Writing to ${output}`);
  await writeFile(output, ts);

  console.log("Done!");
}
